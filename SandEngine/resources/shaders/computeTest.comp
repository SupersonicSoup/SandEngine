#version 430 core
#define DOWNSAMPLE 4

layout (local_size_x = 10, local_size_y = 10, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D img;

uniform int windowWidth = 0;
uniform int windowHeight = 0;

uniform int mouseX = 0;
uniform int mouseY = 0;

uniform int leftClick = 0;
uniform int rightClick = 0;

uniform int drawingType = 2;

uniform float time = 0.0f;

float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

struct Particle
{
	int id;
};


// The current 'state' of the screen, this should be read-only and NEVER modified
layout (std430, binding = 1) buffer CurrentState {
	Particle c_parts[];
};

// The updated state of the screen, this should ONLY be written to
layout (std430, binding = 2) buffer ModifiedState {
	Particle m_parts[];
};

// Claims grid
layout (std430, binding = 3) buffer Claims {
	uint claims[];
};

#define AIR 0
#define SOLID 1
#define SOIL 2
#define WATER 3
#define BUBBLE 4
#define FIRE 5


Particle getAt(int x, int y)
{
	if(y < 0 || x < 0 || x >= windowWidth)
	{
		Particle solid;
		solid.id = 1;
		return solid;
	}
	if(y >= windowHeight)
	{
		Particle none;
		none.id = 0;
		return none;
	}
	int index = (y * windowWidth) + x;
	return c_parts[index];
};

Particle getAt(ivec2 pos)
{
	return getAt(pos.x, pos.y);
}

// Returns true if claim was successful
bool Claim(int index)
{
	uint previous = atomicCompSwap(claims[index], 0, 1);
	return previous == 0;
}

bool Claim(ivec2 pos)
{
	int index = (pos.y * windowWidth) + pos.x;
	return Claim(index);
}



// If particles at positions A and B are unclaimed, return true
/*bool CanSwapParticles(ivec2 a, ivec2 b)
{
	int index_a = (a.y * windowWidth) + a.x;
	int index_b = (b.y * windowWidth) + b.x;
	return !isClaimed(a) && !isClaimed(b);
}*/

void setAt(int x, int y, int id)
{
	if(y >= windowHeight || y < 0 || x < 0 || x >= windowWidth)
	{
		return;
	}
	int index = (y * windowWidth) + x;
	//if(TryClaim(index))
	//{
		Particle p;
		p.id = id;
		m_parts[index] = p;
	//}
};

void setAt(ivec2 pos, int id)
{
	setAt(pos.x, pos.y, id);
}

#define UP ivec2(0, 1)
#define UPLEFT ivec2(-1, 1)
#define UPRIGHT ivec2(1, 1)
#define LEFT ivec2(-1, 0)
#define RIGHT ivec2(1, 0)
#define DOWN ivec2(0, -1)
#define DOWNLEFT ivec2(-1, -1)
#define DOWNRIGHT ivec2(1, -1)


vec3 GetColorAt(int x, int y)
{
	float colorVariation = rand(ivec2(x, y)) * 0.05;
	vec3 color;
	Particle current = getAt(x, y);

	if(current.id == SOLID)
	{
		color = vec3(0.2 + colorVariation, 0.2 + colorVariation, 0.2 + colorVariation);
	}
	else if(current.id == SOIL)
	{
		if(getAt(x, y + 1).id != current.id)
		{
			color = vec3(colorVariation, 1.0f - colorVariation, colorVariation);
		} else {
			color = vec3(0.5f - colorVariation, 0.4 - colorVariation, 0.3 - colorVariation);
		}
	}
	else if (current.id == WATER)
	{
		if(getAt(x, y + 1).id != current.id)
		{
			color = vec3(0.8 - colorVariation, 0.8 - colorVariation, 1.0 - colorVariation);
		} else {
			color = vec3(0.2 + colorVariation, 0.2 + colorVariation, 0.6 + colorVariation);
		}
	} 
	else if(current.id == BUBBLE)
	{
		color = vec3(1.0, 1.0, 1.0);
	}
	else if(current.id == FIRE)
	{
		vec3 red = vec3(0.7 + colorVariation, 0.2 + colorVariation, 0.2 + colorVariation);
		vec3 yellow = vec3(0.9 + colorVariation, 0.9 + colorVariation, 0.2 + colorVariation);
		vec3 fireColor = mix(red, yellow, rand(ivec2(x, y) * time));
		color = fireColor;
	}
	else {
		color = vec3(0.05, 0.05, 0.2);
	} 
	return color;
}

void main() {
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

	Particle current = getAt(pos.x, pos.y);


	if(leftClick == 1) {
		ivec2 cursorPos = ivec2(mouseX, windowHeight - mouseY);
		if(length(cursorPos - pos) < 4) {
			setAt(pos.x, pos.y, drawingType);
		}
	}

	if(rightClick == 1) {
		ivec2 cursorPos = ivec2(mouseX, windowHeight - mouseY);
		if(length(cursorPos - pos) < 4) {
			setAt(pos.x, pos.y, 0);
		}
	}

	// Get neighbors
	Particle nUp = getAt(pos + UP);
	Particle nUpLeft = getAt(pos + UPLEFT);
	Particle nUpRight = getAt(pos + UPRIGHT);

	Particle nLeft = getAt(pos + LEFT);
	Particle nRight = getAt(pos + RIGHT);
	
	Particle nDown = getAt(pos + DOWN);
	Particle nDownLeft = getAt(pos + DOWNLEFT);
	Particle nDownRight = getAt(pos + DOWNRIGHT);


	// TODO: Write better functions for swapping two particles, make it easier to swap particles randomly diagonally (like for bubbles)
	// Need to simplify conditionals

	if(current.id > 0) {
		// Soil
		if(current.id == SOIL) {
			if(nDown.id == AIR && Claim(pos + DOWN)) {
				setAt(pos + DOWN, current.id);
				setAt(pos, AIR);
			} else if (nDown.id == WATER || nDown.id == BUBBLE && Claim(pos + DOWN)) { // Sink in water
				setAt(pos + DOWN, current.id);
				// Randomly create bubbles
				if(rand(pos) > 0.01) {
					setAt(pos, WATER);
				} else {
					setAt(pos, BUBBLE);
				}
			} else {
				int directionBias = (rand(pos) > 0.5)?1:-1;
				// Pick a random direction to go from here
				if (getAt(pos.x + directionBias, pos.y - 1).id == AIR && Claim(ivec2(pos.x + directionBias, pos.y - 1))) {
					setAt(pos.x + directionBias, pos.y - 1, current.id);
					setAt(pos.x, pos.y, AIR);
				} else if (getAt(pos.x + directionBias, pos.y - 1).id == WATER && Claim(ivec2(pos.x + directionBias, pos.y - 1))) {
					setAt(pos.x + directionBias, pos.y -1, current.id);
					setAt(pos, WATER);
				} 
				/*else if (getAt(pos.x - directionBias, pos.y - 1).id == 0 && Claim(ivec2(pos.x - directionBias, pos.y - 1))) {
					setAt(pos.x - directionBias, pos.y -1, current.id);
					setAt(pos.x, pos.y, 0);
				}*/
			}
			
		}

		// Water
		if(current.id == WATER) {
			// If DOWN is free, move DOWN
			if(nDown.id == AIR && Claim(pos + DOWN)) {
				setAt(pos + DOWN, current.id);
				setAt(pos, AIR);
			} else {
				// If ALL 3 below are solid, move left or right
				if(nDownLeft.id != AIR && nDown.id != AIR && nDownRight.id != AIR)
				{
					// If the pixel to one side is solid but other side is free, move that way
					int directionBias = (rand(pos * time) > 0.5)?1:-1;
					if (getAt(pos.x + directionBias, pos.y).id != AIR && getAt(pos.x - directionBias, pos.y).id == AIR && Claim(ivec2(pos.x - directionBias, pos.y)))
					{
						setAt(pos.x - directionBias, pos.y, current.id);
						setAt(pos, AIR);
					}
					// If stranded, bias towards directions featuring water
					if (nLeft.id == AIR && (getAt(pos + LEFT + LEFT).id == WATER) && Claim(pos + LEFT))
					{
						setAt(pos + LEFT, current.id);
						setAt(pos, AIR);
					} else if (nRight.id == AIR && (getAt(pos + RIGHT + RIGHT).id == WATER) && Claim(pos + RIGHT))
					{
						setAt(pos + RIGHT, current.id);
						setAt(pos, AIR);
					} else {
						int directionBias2 = (rand(pos * time) > 0.5)?1:-1;
						if (getAt(pos.x + directionBias, pos.y).id == AIR && Claim(ivec2(pos.x + directionBias, pos.y)))
						{
							setAt(pos.x + directionBias, pos.y, current.id);
							setAt(pos, AIR);
						}
					}

				// Otherwise, pick a random downward diagonal to go and try and go there
				} else {
					int directionBias = (rand(pos * time) > 0.5)?1:-1;
					if (getAt(pos.x + directionBias, pos.y - 1).id == AIR && Claim(ivec2(pos.x + directionBias, pos.y - 1))) {
						setAt(pos.x + directionBias, pos.y - 1, current.id);
						setAt(pos.x, pos.y, AIR);
					}
				}
			}
		}

		if(current.id == BUBBLE)
		{
			int jitter = (rand(pos * time) > 0.5)?1:-1;
			if(nUp.id == WATER && Claim(pos + ivec2(jitter, jitter) + UP))
			{
				setAt(pos + ivec2(jitter, jitter) + UP, BUBBLE);
				setAt(pos, WATER);
			} else if (nUp.id == AIR) {
				setAt(pos.x, pos.y, WATER);
			}
		}

		if (current.id == FIRE)
		{
			int jitter = (rand(pos * time) > 0.5)?1:-1;
			bool die = (rand(pos * time) > 0.8);
			bool spread = (rand(pos * time) > 0.8);

			if(nLeft.id != AIR && spread)
			{
				if (Claim(pos + LEFT)) {
					setAt(pos + LEFT, FIRE);
				}
			}

			if(nRight.id != AIR && spread)
			{
				if (Claim(pos + RIGHT)) {
					setAt(pos + RIGHT, FIRE);
				}
			}

			if(nUpLeft.id != AIR && spread)
			{
				if (Claim(pos + UPLEFT)) {
					setAt(pos + UPLEFT, FIRE);
				}
			}

			if(nUp.id != AIR && spread)
			{
				if (Claim(pos + UP)) {
					if(getAt(pos + UP).id == FIRE)
					{
						setAt(pos, AIR);
					}
					setAt(pos + UP, FIRE);
				}
			}

			if(nUpRight.id != AIR && spread)
			{
				if (Claim(pos + UPRIGHT)) {
					setAt(pos + UPRIGHT, FIRE);
				}
			}

			if(nDown.id != AIR && spread)
			{
				if (Claim(pos + DOWN)) {
					setAt(pos + DOWN, FIRE);
				}
			}

			if(nUp.id == AIR && Claim(pos + ivec2(jitter, jitter) + UP)) {
				if(rand(pos * time) > 0.7) {
				if(die)
				{
					setAt(pos, AIR);
				} else {
					setAt(pos + ivec2(jitter, jitter) + UP, FIRE);
					setAt(pos, AIR);
				}
				}
			}
		}
	}

	vec3 leftColor = GetColorAt(pos.x - 1, pos.y);
	vec3 rightColor = GetColorAt(pos.x + 1, pos.y);
	vec3 upColor = GetColorAt(pos.x, pos.y + 1);
	vec3 downColor = GetColorAt(pos.x, pos.y - 1);
	vec3 thisColor = GetColorAt(pos.x, pos.y);
	vec3 avgColor = (leftColor + rightColor + upColor + downColor + thisColor) / 5;

	vec4 color = vec4(thisColor, 1.0);

	imageStore(img, pos, color);
}